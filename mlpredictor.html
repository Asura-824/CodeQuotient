<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/assests/style.css">
	<link rel="icon" style="border-radius:50%;" href="/Images/myimage.jpg" type="image/jpg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
	<title>Advanced Data Analysis & Forecast Tool</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<style>
		/* FIXES FOR FULL WIDTH HEADER AND MARGINS */
        body { 
            margin: 0; /* FIX: Remove default browser margins */
            padding: 0; /* Override padding from Tailwind classes on body */
        }
        .header1 { /* Target the outer header element for fixed positioning */
            background-color: #F5F5F5; /* Use specific header background */
            padding: 1 0px; /* Slightly reduced padding */
            position: relative;
            top: 0;
            color: #000000;
            z-index: 20;
            width: 100%;
            box-shadow: var(--shadow);
            border-bottom: 1px solid rgba(223, 223, 223, 0.986);
        }
        .header-top1 .search-bar1 {
                text-align: center;
                width: 100px !important;
                border: none;
                border-radius: 8px;
                height: 39px;
                margin: auto;
                padding: 0.3rem 0.5rem !important;
                background-color:rgb(226, 224, 224);
        }
        .container1{
            width: 100%;
            max-width: none; /* Slightly wider max-width */
            margin: 0 auto;
            padding: 0;
            padding-right: 1rem;
        }
        .secondary-nav input{
            display:none;
        }
        .sidebar-section1 {
            display: none; /* Hide sidebar by default */
        }
        nav {
            display: flex;
            align-items: center;
            width: 100%; /* Take full width of parent to distribute items */
        }
        .logo1 {
            display: flex;
            align-items: center;
            text-align: center;
            font-size: 1.5rem; /* Adjusted font size */
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            padding: 0px;
            margin-left: 0rem;
            margin-right: 0.5rem; /* Space between logo and nav links */
            white-space: nowrap; /* Prevent logo text from wrapping */
        }
        .logo1 img {
            width: 50px; /* Adjusted size */
            height: 50px; /* Adjusted size */
            padding: 8px;
            filter: invert(0); /* Invert color for dark background */
        }
        /* Ensure the inner content still has the original padding/layout */
        .header-top1 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 0;
            padding-right: 0;
            padding-left: 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            padding-bottom: 0; /* Space between top and bottom parts of header */
            gap:1rem /* Divider */
        }

        .right-section1 {
            display: flex;
            align-items: center;
            gap: 0.8rem; /* Space between items in the right section */
        }
        
        .navlinks1 {
            display: flex;
            list-style: none;
            flex-grow: 1; /* Allow nav links to take up available space */
            justify-content: flex-start; /* Align to the start */
        }
        .navlinks1 li {
            margin-right: 2rem;
            border-radius: 8px; 
            width: 70px;
            align-items: center;
            text-align: center;/* Adjusted margin between links */
        }
        .navlinks1 a {
            font-size: 1rem;
            color: black;
            font-family: 'Poppins', sans-serif;
            text-decoration: none;
            padding: 0.5rem 0;
            position: relative;
            transition: var(--transition);
            white-space: nowrap; /* Prevent nav links from wrapping */
        }
        .navlinks1 li:hover{
            background-color: #e4e4e4;
        }
        
		#chart { min-height: 400px; width: 100%; }
		/* Override for chart canvas responsiveness */
		#chart-container { position: relative; width: 100%; height: 500px; }
		/* Modal styles */
		.modal-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.6);
			display: none;
			justify-content: center;
			align-items: center;
			z-index: 1000;
		}
		.modal-content {
			background: white;
			padding: 24px;
			border-radius: 12px;
			width: 90%;
			max-width: 600px;
			box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
		}
		/* Custom style for grouped prediction results for better readability */
		.group-result {
			max-height: 300px;
			overflow-y: auto;
		}
	</style>

	<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/regression@2.0.1/dist/regression.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body class="bg-gray-50 text-gray-800">
<header class="header1 p-2">
        <div class="container1">
            <div class="header-top1">
                <div class="logo1">
                    <img src="/Images/logo.png" alt="logo">
                    SHUBHAM's CodeQuotient
                </div>
                <nav class="nav ml-12">
                    <ul class="navlinks1">
                        <li><a href="index.html">Home</a></li>
                        <li><a href="features.html">Features</a></li>
                        <li><a href="resume.html">Resume</a></li>
                        <li><a href="/Projects/projects.html">Projects</a></li>
                        <li><a href="contactus.html">Contact</a></li>
                    </ul>
                </nav>
                <div class="right-section1">
                    <input type="text" placeholder="Search..." class="search-bar1">  
                    
                    <div class="logged-out-buttons" id="logged-out-buttons">
                        <button class="header-button" onclick="location.href='/Login/login.html'">Login</button>
                        <button class="header-button" onclick="location.href='/Signup/signup.html'">Signup</button>
                    </div>

                    <div class="user-info" id="user-info">
                        <span class="user-name" id="display-user-email">Hello, User!</span>
                        <button class="logout-button">Logout</button>
                    </div>
                </div>
            </div>
            <div class="header-bottom1">
                <ul class="secondary-nav">
                    <input type="text" placeholder="Search..." class="search-bar">
                    <li class="dropdown">
                    <a href="#tutorials">Tutorials <i class="fas fa-chevron-down dropdown-icon"></i></a>
                    <div class="dropdown-content">
                            <a href="/Tutorials/Github/github.html">GitHub</a>
                            <a href="/Tutorials/Python/python.html">Python</a>
                            <a href="/Tutorials/SQL/sql.html">Sql</a>
                            <a href="/Tutorials/Pandas/pandas.html">Pandas</a>
                            <a href="/Tutorials/Numpy/numpy.html">NumPy</a>
                            <a href="/Tutorials/Matplot/matplot.html">Matplot</a>
                            <a href="/Tutorials/R Programming/R programming.html">R programming</a>
                            <a href="/Tutorials/PostgreSQL/postgresql.html">Postgre Sql</a>
                            <a href="/Tutorials/Excel/excel.html">Excel</a>
                            <a href="/Tutorials/Power Bi/powerbi.html">Power Bi</a>
                    </div>  
                    </li>
                </ul>
            </div>
            <div class="sidebar-section1">
                <nav>
                    <ul class="navlinks">
                        <li><a href="index.html">Home</a></li>
                        <li><a href="/Projects/projects.html">Projects</a></li>
                        <li><a href="/Tutorials/tutorials.html">Tutorials</a></li>
                        <li><a href="/Datasets/datasets.html">Datasets</a></li>
                        <li><a href="/notes.html">Notes</a></li>
                        <li><a href="/contactus.html">Contact</a></li>
                    </ul>
                </nav>
                <div class="right-section">
                    <button onclick="location.href='Login/login.html'" class="header-button">Login</button>
                    <button class="header-button">Signup</button>
                </div>
            </div>
        </div>
    </header>

<div class="max-w-7xl mx-auto pt-8 mb-12">
	<h1 class="text-3xl font-extrabold text-blue-700 mb-4 flex items-center">
		<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mr-2" viewBox="0 0 20 20" fill="currentColor">
			<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM5 9a1 1 0 000 2h10a1 1 0 100-2H5z" clip-rule="evenodd" />
		</svg>
		Advanced Forecast & Analysis
	</h1>

	<div id="dropzone" class="border-4 border-dashed border-gray-300 bg-white rounded-xl p-8 text-center text-gray-600 transition duration-300 hover:border-blue-500 hover:text-blue-600 shadow-md">
		<p class="font-semibold text-lg">Drop a CSV or XLSX file here</p>
		<p class="text-sm my-2">or select a file:</p>
		<input type="file" id="fileInput" accept=".csv,.xlsx" class="block mx-auto">
	</div>

	<div class="mt-6 p-4 bg-white shadow-lg rounded-xl">
		<h2 class="text-xl font-bold mb-3 text-gray-700 border-b pb-2">Forecasting Controls (ML Model Training)</h2>

		<div class="flex flex-wrap gap-10 items-center">
			<label class="font-semibold text-sm">X-Axis Column:
				<select id="xSelect" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-full"></select>
			</label>
			<label class="font-semibold text-sm">Y-Axis Column:
				<select id="ySelect" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-full"></select>
			</label>
			
			<label class="font-semibold text-sm">Group-By Column:
				<select id="groupForecastSelect" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 w-full"></select>
			</label>
			
			<label class="font-semibold text-sm w-full md:w-auto">Filter Values (Comma-separated):
				<input type="text" id="filterInput" placeholder="e.g., State A, State B" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 w-full md:w-64">
			</label>

			<label class="font-semibold text-sm">Model Type:
				<select id="modelSelect" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-auto">
					<option value="linear">Linear (Polynomial 1)</option>
					<option value="polynomial">Polynomial</option>
					<option value="exponential">Exponential</option>
					<option value="logarithmic">Logarithmic</option>
				</select>
			</label>
			<label id="degreeLabel" class="font-semibold text-sm">Degree:
				<select id="degreeSelect" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-full">
					<option value="2">Quadratic (2)</option>
					<option value="3">Cubic (3)</option>
					<option value="4">Quartic (4)</option>
				</select>
			</label>
			<label class="font-semibold text-sm">Steps Ahead:
				<input type="number" id="stepCount" value="5" min="1" max="50" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-20">
			</label>
			
			<label class="font-semibold text-sm">Target X Value:
				<input type="text" id="targetXInput" placeholder="Optional: E.g., 15 or 2026" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-35">
			</label>

			<button id="forecastBtn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
				Run Forecast
			</button>
		</div>
	</div>

	<div class="mt-6 p-4 bg-white shadow-lg rounded-xl">
		<h2 class="text-xl font-bold mb-3 text-gray-700 border-b pb-2">Data Aggregation & Descriptive Analysis</h2>
		<div class="flex flex-wrap gap-20 items-center w-full">
			
			<button id="aggregateBtn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md">
				Group & Aggregate Data
			</button>

			<label class="font-semibold text-sm">Descriptive Analysis on:
				<select id="groupSelect" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 w-full"></select>
			</label>
			<button id="descriptiveBtn" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition duration-150 shadow-md">
				Analyze Column
			</button>
			
			<button id="exportBtn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-150 shadow-md">
				Download Chart (PNG)
			</button>
		</div>
	</div>

	<div id="chart-container" class="mt-6 bg-white p-4 rounded-xl shadow-lg">
		<canvas id="chart"></canvas>
	</div>
	
	<div id="result" class="mt-6 p-4 bg-white rounded-xl shadow-lg whitespace-pre-line text-sm text-gray-700">
		Load a CSV or XLSX file to begin analysis and forecasting.
	</div>
</div>

<div id="aggregationModal" class="modal-overlay">
	<div class="modal-content">
		<h3 class="text-2xl font-bold text-indigo-700 mb-4">Multi-Column Data Aggregation</h3>
		<p class="text-sm text-gray-600 mb-4">Create a new dataset by grouping rows and calculating a summary statistic (Count, Sum, or Average).</p>

		<div class="space-y-4">
			<div>
				<label class="block font-semibold text-sm mb-1">Grouping Column 1 (Primary Key - MANDATORY):</label>
				<select id="aggGroup1Select" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 w-full"></select>
			</div>

			<div>
				<label class="block font-semibold text-sm mb-1">Grouping Column 2 (Secondary Key - OPTIONAL):</label>
				<select id="aggGroup2Select" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 w-full"></select>
			</div>

			<hr class="border-gray-200">

			<div>
				<label class="block font-semibold text-sm mb-1">Aggregation Function:</label>
				<select id="aggTypeSelect" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 w-full">
					<option value="count">Count (rows per group)</option>
					<option value="sum">Sum (of Value Column)</option>
					<option value="mean">Average (of Value Column)</option>
				</select>
			</div>

			<div id="aggValueContainer">
				<label class="block font-semibold text-sm mb-1">Value Column to Sum/Average:</label>
				<select id="aggValueSelect" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 w-full"></select>
			</div>
		</div>

		<div class="flex justify-end space-x-3 mt-6">
			<button id="closeModalBtn" class="bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-400 transition duration-150 shadow-md">
				Cancel
			</button>
			<button id="runAggBtn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md">
				Generate New Dataset
			</button>
		</div>
	</div>
</div>
<footer id="contact" class="footer bg-white-800 text-black text-center mt-12 p-6">
        <div class="footercontainer">
            <h3 class="langtitle">Connect with me for the better experience and the knowledge</h3>
        </div>
        <div class="social-links">
                <a href="https://www.youtube.com/@LEARNWITHSKADAM_6457" style="--accent-color:red;" aria-label="Youtube"><img src="/Images/youtube.jpg" alt="Youtube" width="31px"></a>
                <a href="https://github.com/Asura-824" style="--accent-color: rgb(52, 52, 52);" aria-label="Github"><img src="/Images/github.png" alt="Github" width="31px"></a>
                <a href="https://www.linkedin.com/in/shubham-kadam-b8856031a?lipi=urn%3Ali%3Apage%3Ad_flagship3_profile_view_base_contact_details%3BUAYDKko9S02GUSRNrD3vJg%3D%3D" style="--accent-color:rgb(25, 67, 233);" aria-label="Linkedin"><img src="/Images/linkedin.png" alt="Linkedin" width="35px"></a>
        </div>
        <div class="footerp">
            <p style="font-size:bold;">Made with ❤️ by SHUBHAM</p>
            <p>Code is like poetry Some get it,some don't<br>Those who don't get it,are <b style="color: #f80404;"> confused.</b><br>Those who get it,are even <b style="color:#f80404;">more confused.</b></p>
            <p class="copyright">© 2025 SHUBHAM's CodeQuotient. All rights reserved.</p>
        </div>
</footer>
<script>
// Global variables for access
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const ctx = document.getElementById('chart').getContext('2d');
const resultDiv = document.getElementById('result');
const xSelect = document.getElementById('xSelect');
const ySelect = document.getElementById('ySelect');
const modelSelect = document.getElementById('modelSelect');
const degreeSelect = document.getElementById('degreeSelect');
const degreeLabel = document.getElementById('degreeLabel');
const groupSelect = document.getElementById('groupSelect');
const descriptiveBtn = document.getElementById('descriptiveBtn'); 
const aggregateBtn = document.getElementById('aggregateBtn'); 
const stepInput = document.getElementById('stepCount');
const targetXInput = document.getElementById('targetXInput');
const groupForecastSelect = document.getElementById('groupForecastSelect'); 
const filterInput = document.getElementById('filterInput'); // NEW

// Aggregation Modal elements
const aggregationModal = document.getElementById('aggregationModal');
const aggGroup1Select = document.getElementById('aggGroup1Select');
const aggGroup2Select = document.getElementById('aggGroup2Select');
const aggTypeSelect = document.getElementById('aggTypeSelect');
const aggValueSelect = document.getElementById('aggValueSelect');
const aggValueContainer = document.getElementById('aggValueContainer');
const runAggBtn = document.getElementById('runAggBtn');
const closeModalBtn = document.getElementById('closeModalBtn');


let chart, parsedData = [], originalData = [], headers = [];

// --- File Loading and Parsing ---

function loadFile(file) {
	const reader = new FileReader();
	const isExcel = file.name.endsWith('.xlsx');

	// Display loading state
	resultDiv.innerHTML = '<span class="text-blue-500">Loading and parsing file...</span>';

	reader.onload = e => {
		if (isExcel) {
			// Handle XLSX
			const data = new Uint8Array(e.target.result);
			const workbook = XLSX.read(data, { type: 'array' });
			const sheetName = workbook.SheetNames[0];
			const sheet = workbook.Sheets[sheetName];
			const csv = XLSX.utils.sheet_to_csv(sheet);
			
			// Use PapaParse on the generated CSV for reliable dynamic typing
			Papa.parse(csv, {
				header: true,
				dynamicTyping: true, 
				skipEmptyLines: true,
				complete: ({ data, meta }) => handleParsedData(data, meta.fields)
			});
		} else {
			// Handle CSV
			Papa.parse(file, {
				header: true,
				dynamicTyping: true,
				skipEmptyLines: true,
				complete: ({ data, meta }) => handleParsedData(data, meta.fields)
			});
		}
	};

	try {
		isExcel ? reader.readAsArrayBuffer(file) : reader.readAsText(file);
	} catch (error) {
		resultDiv.textContent = 'Error reading file: ' + error.message;
	}
}

function handleParsedData(data, fields) {
	// Filter rows where all values might be null or empty
	parsedData = data.filter(row => Object.values(row).some(val => val !== null && val !== '' && (typeof val !== 'string' || val.trim() !== '')));
	
	// Store original data as backup before aggregation
	originalData = [...parsedData];

	// Clean headers: filter out headers that don't appear in any data row
	headers = fields.filter(f => parsedData.some(row => row.hasOwnProperty(f)));

	if (headers.length === 0) {
		resultDiv.textContent = 'Error: The file appears empty or the header row is missing/invalid.';
		if (chart) chart.destroy();
		return;
	}
	
	populateSelectors(headers);
	autoSelectNumericColumns(parsedData.find(row => row));
	runForecast(); // Run initial forecast
}

function populateSelectors(fields) {
	// Selectors for Forecast/Descriptive Analysis
	[xSelect, ySelect, groupSelect, groupForecastSelect].forEach(select => select.innerHTML = '');
	
	// Selectors for Aggregation Modal
	[aggGroup1Select, aggGroup2Select, aggValueSelect].forEach(select => select.innerHTML = '');

	// Add 'None' option for optional Grouping columns
	const noneOpt1 = document.createElement('option');
	noneOpt1.value = '__NONE__';
	noneOpt1.textContent = '-- None (Single Model) --';
	groupForecastSelect.appendChild(noneOpt1);

	const noneOpt2 = document.createElement('option');
	noneOpt2.value = '__NONE__';
	noneOpt2.textContent = '-- None --';
	aggGroup2Select.appendChild(noneOpt2);

	fields.forEach(f => {
		// Populate Forecast/Descriptive/Group-By
		[xSelect, ySelect, groupSelect, groupForecastSelect].forEach(select => {
			const opt = document.createElement('option');
			opt.value = opt.textContent = f;
			select.appendChild(opt);
		});

		// Populate Aggregation Modal
		[aggGroup1Select, aggGroup2Select, aggValueSelect].forEach(select => {
			const opt = document.createElement('option');
			opt.value = opt.textContent = f;
			select.appendChild(opt);
		});
	});
	
	// Reset to default
	groupForecastSelect.value = '__NONE__';
	aggGroup2Select.value = '__NONE__'; 
}

function autoSelectNumericColumns(sample) {
	if (!sample) return;
	// Try to find the first two numeric columns
	const numeric = headers.filter(h => typeof sample[h] === 'number');
	if (numeric.length >= 2) {
		xSelect.value = numeric[0];
		ySelect.value = numeric[1];
	} else if (numeric.length === 1) {
			// If only one numeric column, use a simple index (0, 1, 2, ...) for X
			const timeIndex = 'Row Index (Time)';
			const opt = document.createElement('option');
			opt.value = opt.textContent = timeIndex;
			xSelect.prepend(opt);
			xSelect.value = timeIndex;
			ySelect.value = numeric[0];
	}
}

// --- Multi-Column Aggregation ---

function showAggregationModal() {
	if (parsedData.length === 0) {
		resultDiv.textContent = 'Error: Please load a file before attempting aggregation.';
		return;
	}
	// Re-populate selectors in case the original data was re-loaded
	populateSelectors(headers);
	
	// Initial state for Count aggregation (Value Column is not needed)
	aggValueContainer.style.display = 'none';

	aggregationModal.style.display = 'flex';
}

function runAggregation() {
	const groupCol1 = aggGroup1Select.value;
	const groupCol2 = aggGroup2Select.value;
	const aggType = aggTypeSelect.value;
	const aggValueCol = aggValueSelect.value;
	
	if (!groupCol1) {
		resultDiv.textContent = 'Error: Primary Grouping Column 1 must be selected.';
		return;
	}
	if ((aggType === 'sum' || aggType === 'mean') && !aggValueCol) {
		resultDiv.textContent = `Error: For ${aggType}, a Value Column must be selected.`;
		return;
	}

	const newAggregatedData = {};
	const isTwoGroup = groupCol2 !== '__NONE__';
	let validCount = 0;

	// 1. Group Data
	originalData.forEach(row => {
		const key1 = String(row[groupCol1]);
		let key2 = isTwoGroup ? String(row[groupCol2]) : '';
		
		if (key1.trim() === '' || (isTwoGroup && key2.trim() === '')) return; 

		const groupKey = isTwoGroup ? `${key1} | ${key2}` : key1;

		if (!newAggregatedData[groupKey]) {
			newAggregatedData[groupKey] = { 
				count: 0, 
				sum: 0,
				group1Value: row[groupCol1], 
				group2Value: isTwoGroup ? row[groupCol2] : null,
			};
		}
		
		newAggregatedData[groupKey].count++;
		validCount++;
		
		if (aggType === 'sum' || aggType === 'mean') {
			const value = row[aggValueCol];
			if (typeof value === 'number' && !isNaN(value)) {
				newAggregatedData[groupKey].sum += value;
			}
		}
	});
	
	if (validCount === 0) {
		aggregationModal.style.display = 'none';
		resultDiv.textContent = 'Error: No valid data found for the selected grouping columns.';
		return;
	}

	// 2. Transform into final aggregated array
	const newHeaders = [groupCol1];
	if (isTwoGroup) newHeaders.push(groupCol2);
	
	let newColumnName;
	let aggregatedResults = [];

	for (const key in newAggregatedData) {
		const group = newAggregatedData[key];
		let aggValue;
		
		if (aggType === 'count') {
			newColumnName = `Count_of_Rows`;
			aggValue = group.count;
		} else if (aggType === 'sum') {
			newColumnName = `Sum_of_${aggValueCol}`;
			aggValue = group.sum;
		} else { // mean
			newColumnName = `Avg_of_${aggValueCol}`;
			aggValue = group.sum / group.count;
		}
		
		const newRow = {};
		newRow[groupCol1] = group.group1Value;
		if (isTwoGroup) {
			newRow[groupCol2] = group.group2Value;
		}
		newRow[newColumnName] = aggValue;
		aggregatedResults.push(newRow);
	}
	
	newHeaders.push(newColumnName);

	// 3. Update global state and UI
	parsedData = aggregatedResults;
	headers = newHeaders;
	
	populateSelectors(headers);
	
	// Automatically select the grouping column 1 as X and the new aggregated column as Y
	xSelect.value = groupCol1;
	ySelect.value = newColumnName;

	aggregationModal.style.display = 'none';
	runForecast();
	
	resultDiv.innerHTML = `<p class="font-bold text-lg mb-2 text-indigo-800">Aggregation Successful!</p>
		<p>The original dataset (${originalData.length} rows) has been replaced by a new dataset with **${aggregatedResults.length} unique groups**. Use the forecasting controls above to model the new aggregated data.</p>
		<p class="mt-2 text-sm">New Columns: ${newHeaders.join(', ')}</p>
	`;
}

// --- Regression and Forecasting ---

function drawChart(points, regOrResult, forecasts, isSinglePrediction = false, isGrouped = false) {
	const xCol = xSelect.value;
	const yCol = ySelect.value;
	const modelType = modelSelect.value;
	const degree = modelSelect.value === 'polynomial' ? degreeSelect.value : (modelType === 'linear' ? 1 : '');
	
	const reg = isGrouped ? regOrResult.reg : regOrResult; // Extract regression object if grouped

	// 1. Prepare Data
	const regressionPoints = points.map(([x, y]) => ({x, y}));
	
	// 2. Prepare Regression Line (100 steps for smoothness)
	const allX = points.map(p => p[0]).concat(forecasts.map(f => f.x));
	const minX = Math.min(...allX);
	const maxX = Math.max(...allX);
	
	const linePoints = [];
	// Use a small step for the line calculation, starting slightly before the min observed X
	for (let x = minX > 0 ? minX - 1 : minX; x <= maxX; x += (maxX - minX + 1) / 100) {
		const predicted = reg.predict(x);
		if (predicted && typeof predicted[1] === 'number') {
				linePoints.push({ x: x, y: predicted[1] });
		}
	}

	// Determine the correct data set for the forecast to plot it correctly
	let forecastData = forecasts.map(f => ({ x: f.x, y: f.y }));
	let forecastType = 'line';
	let forecastDash = [5, 5];
	let forecastLabel = 'Forecasted Values';

	if (isSinglePrediction) {
			forecastType = 'scatter'; 
			forecastDash = [];
			forecastLabel = `Target Prediction @ X=${forecasts[0].x.toFixed(2)}`;
	}
	
	const chartTitle = isGrouped 
		? `ML Forecast of ${yCol} based on ${xCol} (Group: ${regOrResult.groupValue})`
		: `ML Forecast of ${yCol} based on ${xCol} (${modelType}${degree ? ' Degree ' + degree : ''})`;

	// 3. Render Chart
	if (chart) chart.destroy();
	chart = new Chart(ctx, {
		type: 'scatter',
		data: {
			datasets: [
				{
					label: 'Actual Data Points',
					data: regressionPoints,
					backgroundColor: 'rgba(75, 192, 192, 1)',
					pointRadius: 6,
					pointBorderWidth: 1,
					pointBackgroundColor: 'white'
				},
				{
					label: `Model Line (R²: ${reg.r2.toFixed(4)})`,
					data: linePoints,
					type: 'line',
					fill: false,
					borderColor: 'rgba(255, 99, 132, 1)',
					borderWidth: 2,
					pointRadius: 0
				},
				{
					label: forecastLabel,
					data: forecastData,
					type: forecastType,
					borderDash: forecastDash,
					fill: false,
					borderColor: 'rgba(54, 162, 235, 1)',
					borderWidth: isSinglePrediction ? 0 : 2, 
					pointRadius: 8,
					pointStyle: isSinglePrediction ? 'rectRot' : 'circle', 
					backgroundColor: 'rgba(54, 162, 235, 1)'
				}
			]
		},
		options: {
			responsive: true,
			maintainAspectRatio: false,
			plugins: {
				title: {
					display: true,
					text: chartTitle,
					font: { size: 16, weight: 'bold' }
				},
				tooltip: {
						callbacks: {
								label: (context) => {
										return `${context.dataset.label}: (${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
								}
						}
				}
			},
			scales: {
				x: {
					type: 'linear',
					position: 'bottom',
					title: { display: true, text: xCol, font: { weight: 'bold' } }
				},
				y: {
					title: { display: true, text: yCol, font: { weight: 'bold' } }
				}
			}
		}
	});
}

// Helper to train a model based on points
function trainModel(points, modelType, degree) {
	let reg;
	let validPoints = points;

	if (modelType === 'exponential' || modelType === 'logarithmic') {
		validPoints = points.filter(p => p[1] > 0);
	}
	
	if (validPoints.length < (modelType === 'polynomial' ? degree + 1 : 2)) {
		throw new Error(`Need at least ${modelType === 'polynomial' ? degree + 1 : 2} points for this model.`);
	}

	if (modelType === 'polynomial' || modelType === 'linear') {
		reg = regression.polynomial(validPoints, { order: modelType === 'linear' ? 1 : degree });
	} else if (modelType === 'exponential') {
		reg = regression.exponential(validPoints);
	} else if (modelType === 'logarithmic') {
		reg = regression.logarithmic(validPoints);
	}

	if (!reg) throw new Error('Model training failed unexpectedly.');
	return reg;
}

// Generates forecasts based on the trained model
function generateForecasts(reg, points, steps, targetXValue) {
	let forecasts = [];
	let isSinglePrediction = targetXValue !== '';

	if (isSinglePrediction) {
		const targetX = parseFloat(targetXValue);
		if (isNaN(targetX)) {
			throw new Error('Target X Value must be a valid number.');
		}
		const predictedY = reg.predict(targetX)[1];
		forecasts.push({ x: targetX, y: predictedY });
	} else {
		const lastX = points.length > 0 ? points[points.length - 1][0] : 0;
		for (let i = 1; i <= steps; i++) {
			const nextX = lastX + i;
			const nextY = reg.predict(nextX)[1];
			forecasts.push({ x: nextX, y: nextY });
		}
	}
	return { forecasts, isSinglePrediction };
}


function runSingleForecast(xCol, yCol, modelType, degree, steps, targetXValue) {
	// 1. Prepare points (handle 'Row Index' virtual column)
	let points = parsedData
		.map((row, index) => {
				const x = xCol === 'Row Index (Time)' ? index : row[xCol];
				return [x, row[yCol]];
		})
		.filter(p => typeof p[0] === 'number' && typeof p[1] === 'number');

	if (points.length === 0) {
		resultDiv.textContent = `No valid numeric data found for X: "${xCol}" and Y: "${yCol}".`;
		if (chart) chart.destroy();
		return;
	}

	try {
		const reg = trainModel(points, modelType, degree);
		const { forecasts, isSinglePrediction } = generateForecasts(reg, points, steps, targetXValue);

		drawChart(points, reg, forecasts, isSinglePrediction);
		
		let predictionHeader = isSinglePrediction ? `Specific Prediction for X = ${forecasts[0].x.toFixed(2)}:` : `Future Predictions (${steps} steps):`;
		
		resultDiv.innerHTML = `<p class="font-bold text-lg mb-2 text-blue-800">ML Model Training & Forecast Results:</p>
			<p class="font-mono bg-gray-100 p-2 rounded-lg break-all">Equation: ${reg.string}</p>
			<p>R-squared (Model Accuracy): <span class="font-bold text-red-600">${reg.r2.toFixed(4)}</span></p>
			<div class="mt-3">
				<p class="font-bold">${predictionHeader}</p>
				<div class="grid grid-cols-2 gap-x-4 gap-y-1 mt-1">
					${forecasts.map(f => `<span>X = ${f.x.toFixed(2)}</span><span class="font-semibold">Y = ${f.y.toFixed(2)}</span>`).join('')}
				</div>
			</div>
			`;
	} catch (error) {
		resultDiv.textContent = `Error training model: ${error.message}. Check data validity and model requirements.`;
		if (chart) chart.destroy();
	}
}

function runGroupedForecast(xCol, yCol, groupByCol, modelType, degree, steps, targetXValue, filterValues) {
	
	// 1. Determine which groups to run the forecast on
	let groupsToAnalyze;
	if (filterValues.length > 0) {
		// Use the user's specific filter list
		groupsToAnalyze = filterValues;
	} else {
		// If filter is empty, use all unique groups in the data
		groupsToAnalyze = [...new Set(parsedData.map(row => row[groupByCol]))]
			.filter(g => g !== null && String(g).trim() !== '');
	}

	let allGroupResults = [];
	let firstSuccessfulGroupResult = null;
	let firstGroupPoints = [];

	// 2. Iterate through each required group
	groupsToAnalyze.forEach((groupValue, groupIndex) => {
		
		// Filter data for the current group (handling case-insensitivity or string conversion if needed)
		const groupData = parsedData.filter(row => String(row[groupByCol]).trim() === String(groupValue).trim());

		// Check if there's any data for this group
		if (groupData.length === 0) {
			allGroupResults.push({ groupValue, error: `No data found in the dataset for this group.` });
			return;
		}

		// Prepare points for this group
		let points = groupData
			.map((row, index) => {
				const x = xCol === 'Row Index (Time)' ? index : row[xCol];
				return [x, row[yCol]];
			})
			.filter(p => typeof p[0] === 'number' && typeof p[1] === 'number');

		try {
			const reg = trainModel(points, modelType, degree);
			const { forecasts, isSinglePrediction } = generateForecasts(reg, points, steps, targetXValue);

			const result = {
				groupValue,
				reg,
				r2: reg.r2,
				equation: reg.string,
				forecasts,
				isSinglePrediction
			};
			allGroupResults.push(result);

			// Store data for the first successful group to plot
			if (!firstSuccessfulGroupResult) {
				firstSuccessfulGroupResult = result;
				firstGroupPoints = points;
			}

		} catch (error) {
			allGroupResults.push({ groupValue, error: `Training failed: ${error.message}` });
		}
	});

	// 3. Display Results
	displayGroupedResults(allGroupResults, groupByCol, xCol, yCol, groupsToAnalyze.length);
	
	// 4. Plot (Only for the first successful group)
	if (firstSuccessfulGroupResult) {
		drawChart(firstGroupPoints, firstSuccessfulGroupResult, firstSuccessfulGroupResult.forecasts, firstSuccessfulGroupResult.isSinglePrediction, true);
	} else {
		if (chart) chart.destroy();
		resultDiv.innerHTML += '<p class="text-red-500 mt-2 font-semibold">Could not plot any group because no group had enough valid data points for the selected model.</p>';
	}
}

function displayGroupedResults(results, groupByCol, xCol, yCol, totalGroups) {
    let html = `<p class="font-bold text-lg mb-2 text-blue-800">Grouped ML Forecast Results (Grouped by: ${groupByCol})</p>
        <p class="text-sm text-gray-600">Trained models for **${results.length}** groups out of **${totalGroups}** requested. Predicting **${yCol}** based on **${xCol}**.</p>`;
	
	// Find the first successful result to reference for the chart note
	const firstSuccessful = results.find(r => !r.error);
	
	if (firstSuccessful) {
		html += `<p class="text-sm text-red-500 font-semibold mb-3">Note: The chart below displays the data and trend line ONLY for the first successful group (**${firstSuccessful.groupValue}**) for visualization purposes.</p>`;
	}

    html += `<div class="space-y-4 group-result">`; // Add group-result class for scrolling

    results.forEach((res) => {
        html += `<div class="p-3 border border-gray-200 rounded-lg shadow-md">
            <h4 class="font-bold text-indigo-700">Group: ${res.groupValue}</h4>`;
        
        if (res.error) {
            html += `<p class="text-red-600">Model Error: ${res.error}</p></div>`;
            return;
        }

        html += `<p class="font-mono text-xs bg-gray-50 p-1 rounded break-all">Equation: ${res.equation}</p>
            <p>R-squared (Model Accuracy): <span class="font-bold text-red-600">${res.r2.toFixed(4)}</span></p>
            <div class="mt-2">
                <p class="font-bold text-sm">${res.isSinglePrediction ? 'Target Prediction' : 'Future Predictions'}:</p>
                <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-xs mt-1">
                    ${res.forecasts.map(f => `<span>X = ${f.x.toFixed(2)}</span><span class="font-semibold">Y = ${f.y.toFixed(2)}</span>`).join('')}
                </div>
            </div>
        </div>`;
    });

    html += `</div>`;
    resultDiv.innerHTML = html;
}

function runForecast() {
	if (parsedData.length === 0) {
		resultDiv.textContent = 'Error: Please load a file first.';
		if (chart) chart.destroy();
		return;
	}
	
	const xCol = xSelect.value;
	const yCol = ySelect.value;
	const steps = parseInt(stepInput.value || '1');
	const degree = parseInt(degreeSelect.value || '1');
	const modelType = modelSelect.value;
	const targetXValue = targetXInput.value.trim();
	const groupByCol = groupForecastSelect.value;
	const filterValuesRaw = filterInput.value.trim();
	
	let filterValues = [];
	if (filterValuesRaw !== '') {
		filterValues = filterValuesRaw.split(',').map(s => String(s).trim()).filter(s => s !== '');
	}

	const isGroupedForecast = groupByCol !== '__NONE__';

	if (isGroupedForecast) {
		runGroupedForecast(xCol, yCol, groupByCol, modelType, degree, steps, targetXValue, filterValues);
	} else {
		runSingleForecast(xCol, yCol, modelType, degree, steps, targetXValue);
	}
}


// --- Descriptive Analysis (Statistical - Renamed from runGroupAnalysis) ---

function runDescriptiveAnalysis() {
	const col = groupSelect.value;
	if (!col) return;

	// Use originalData for descriptive analysis, in case the current parsedData is aggregated
	const values = originalData.map(row => row[col]).filter(val => val !== null && val !== '');
	if (values.length === 0) {
		resultDiv.textContent = `No data found in column "${col}".`;
		if (chart) chart.destroy();
		return;
	}
	
	// Check if the majority of filtered values are numbers
	const numericValues = values.filter(val => typeof val === 'number').sort((a, b) => a - b);
	const isNumeric = numericValues.length / values.length > 0.5;

	if (isNumeric && numericValues.length > 0) {
		// --- Numeric Column Analysis (Summary Statistics) ---
		const count = numericValues.length;
		const sum = numericValues.reduce((a, b) => a + b, 0);
		const mean = sum / count;
		const min = numericValues[0];
		const max = numericValues[count - 1];

		const variance = numericValues.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / count;
		const stdDev = Math.sqrt(variance);

		// Prepare Histogram Data
		const numBins = 10;
		const range = max - min;
		const binSize = range / numBins || 1; // Prevent division by zero if all values are the same
		const bins = Array(numBins).fill(0);
		const binLabels = [];

		for (let i = 0; i < numBins; i++) {
			const lowerBound = min + i * binSize;
			const upperBound = min + (i + 1) * binSize;
			binLabels.push(`${lowerBound.toFixed(2)} to ${upperBound.toFixed(2)}`);
			numericValues.forEach(val => {
				// Use val <= upperBound for the last bin to catch the max value
				if (val >= lowerBound && (i < numBins - 1 ? val < upperBound : val <= upperBound)) {
					bins[i]++;
				}
			});
		}

		if (chart) chart.destroy();
		chart = new Chart(ctx, {
			type: 'bar',
			data: {
				labels: binLabels,
				datasets: [{
					label: `Distribution of ${col} (Count)`,
					data: bins,
					backgroundColor: 'rgba(153, 102, 255, 0.8)',
					borderColor: 'rgba(153, 102, 255, 1)',
					borderWidth: 1
				}]
			},
			options: {
				responsive: true,
				maintainAspectRatio: false,
				plugins: {
					title: { display: true, text: `Distribution of ${col} (Histogram)`, font: { size: 16, weight: 'bold' } }
				},
				scales: {
					x: { title: { display: true, text: 'Value Bins' } },
					y: { beginAtZero: true, title: { display: true, text: 'Count' } }
				}
			}
		});

		resultDiv.innerHTML = `<p class="font-bold text-lg mb-2 text-blue-800">Summary Statistics for Numeric Column "${col}":</p>
			<div class="grid grid-cols-2 gap-x-4 gap-y-1">
				<span>Count:</span> <span class="font-semibold">${count}</span>
				<span>Mean:</span> <span class="font-semibold">${mean.toFixed(2)}</span>
				<span>Min:</span> <span class="font-semibold">${min.toFixed(2)}</span>
				<span>Max:</span> <span class="font-semibold">${max.toFixed(2)}</span>
				<span>Std Dev:</span> <span class="font-semibold">${stdDev.toFixed(2)}</span>
			</div>`;

	} else {
		// --- Categorical Column Analysis (Counts) ---
		const counts = {};
		values.forEach(key => {
			const keyStr = String(key).trim(); // Ensure all keys are strings
			if (keyStr !== '') {
				counts[keyStr] = (counts[keyStr] || 0) + 1;
			}
		});

		const labels = Object.keys(counts);
		const countValues = Object.values(counts);

		if (chart) chart.destroy();
		chart = new Chart(ctx, {
			type: 'bar',
			data: {
				labels: labels,
				datasets: [{
					label: `Count by ${col}`,
					data: countValues,
					backgroundColor: 'rgba(0,128,255,0.8)'
				}]
			},
			options: {
				responsive: true,
				maintainAspectRatio: false,
				plugins: {
					title: { display: true, text: `Group Counts for Categorical Column: ${col}`, font: { size: 16, weight: 'bold' } }
				},
				scales: {
					y: { beginAtZero: true, title: { display: true, text: 'Count' } }
				}
			}
		});

		resultDiv.innerHTML = `<p class="font-bold text-lg mb-2 text-blue-800">Group Counts for Categorical Column "${col}":</p>` +
			labels.map((k, i) => `<div class="flex justify-between border-b pb-1 mb-1"><span>${k}:</span> <span class="font-semibold">${countValues[i]}</span></div>`).join('');
	}
}

// --- Event Listeners and Initialization ---

// Drag-and-drop functionality
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt =>
	dropzone.addEventListener(evt, e => {
		e.preventDefault();
		dropzone.classList.toggle('border-blue-500', evt === 'dragenter' || evt === 'dragover');
		dropzone.classList.toggle('bg-blue-50', evt === 'dragenter' || evt === 'dragover');
	})
);

dropzone.addEventListener('drop', e => {
	const file = e.dataTransfer.files[0];
	if (file && (file.name.endsWith('.csv') || file.name.endsWith('.xlsx'))) {
		loadFile(file);
		dropzone.classList.remove('border-blue-500', 'bg-blue-50');
	} else {
		resultDiv.textContent = 'Please drop a valid .csv or .xlsx file.';
		dropzone.classList.remove('border-blue-500', 'bg-blue-50');
	}
});

fileInput.addEventListener('change', e => {
	if (e.target.files[0]) loadFile(e.target.files[0]);
});

document.getElementById('forecastBtn').addEventListener('click', runForecast);
descriptiveBtn.addEventListener('click', runDescriptiveAnalysis); 

// New listeners for Aggregation Modal
aggregateBtn.addEventListener('click', showAggregationModal);
closeModalBtn.addEventListener('click', () => aggregationModal.style.display = 'none');
runAggBtn.addEventListener('click', runAggregation);

// Toggle Value Column visibility based on aggregation type
aggTypeSelect.addEventListener('change', (e) => {
	const type = e.target.value;
	aggValueContainer.style.display = (type === 'sum' || type === 'mean') ? 'block' : 'none';
});


// Listener to toggle polynomial degree selector
modelSelect.addEventListener('change', runForecast);

// Listeners for column changes and prediction changes (always re-run forecast)
xSelect.addEventListener('change', runForecast);
ySelect.addEventListener('change', runForecast);
groupForecastSelect.addEventListener('change', runForecast); 
degreeSelect.addEventListener('change', runForecast);
stepInput.addEventListener('change', runForecast);
targetXInput.addEventListener('input', runForecast); 
filterInput.addEventListener('input', runForecast); // NEW listener for filter changes

document.getElementById('exportBtn').addEventListener('click', () => {
	if (parsedData.length === 0 || !chart) {
		resultDiv.innerHTML = '<span class="text-red-500 font-bold">Error: Please load data and run an analysis/forecast before exporting the chart.</span>';
		return;
	}
	
	const link = document.createElement('a');
	link.download = `forecast_chart_${Date.now()}.png`;
	link.href = document.getElementById('chart').toDataURL('image/png', 1.0);
	link.click();
});

// Initial Setup
(function initialSetup() {
	// Hide degree selector by default since 'Linear' is selected
	degreeLabel.style.display = 'none';
})();
</script>
<script src="/script/script.js"></script>
</body>
</html>